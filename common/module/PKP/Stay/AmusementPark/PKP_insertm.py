from PKP_Using_Obliged_setBuiltInType import *

@sign(list,"insertm")
def insertm(source,位置表,对象表):
    
    #122333 --> 1a22b333    
    #list.insertm([1,2,2,3,3,3],[1,3],["a","b"])


    #位置表参数值与对象表参数值皆转列表 因为皆有所操作
    if not isinstance(位置表,(list,tuple)):
        位置表=[位置表]
    if not isinstance(对象表,(list,tuple)):
        对象表=[对象表]
        
    位置表,对象表=map(list,(位置表,对象表))
        
    #位置表里的元素必须全为整数
    if not 位置表.istypethisone(int):
        raise TypeError("any element in arg 2 '位置表' is not int")

    #位置个数与对象个数可以不相等
    #前提是要么位置只有1个 要么对象只有1个
    #否则两者个数必须相等
    if not (len(对象表) == 1 or len(位置表)==1 or\
len(对象表)==len(位置表)):
        raise  ValueError("there must be an equal number of element in"+\
" both arg 2 '位置表' and arg 3 '对象表', "+\
"unless there is only one element in either of them")

    from copy import copy
    副本=copy(source)
    确认插入对象=object()
    确认插入到位置=int()
    可能组=list()
    确认组=tuple()
    
    #相同位置
    if len(位置表)==1:
        确认插入到位置=位置表[0]
        for 确认插入对象 in 对象表:
            副本.insert(确认插入到位置,确认插入对象)    
    #不同位置
    else:
        #相同对象
        if len(对象表)==1: 确认插入对象 = 对象表[0]
#先顺序对应
#保存位置表与对象表的对应关系
#dict版跟tuple版都要
#简单情况用dict版足够了 复杂情况再动用tuple版
        对应关系dict版=dict(zip(位置表,对象表))
        对应关系tuple版=tuple(zip(位置表,对象表))
#再排序打乱
#因为我的插入需要根据按从小到大顺序排列的位置表
#所以考虑到位置有可能不是从小到大排列的
#先把位置排序
        位置表.sort()
        #把相同或不同对象循环插入到对应的不同位置
        for index,position in enumerate(位置表):
            #插入需要根据位置
            #所以先把<确认插入到位置>确定下来
            确认插入到位置=position+index
            
            #不同对象
            if not len(对象表)==1:
#<确认插入对象>取决于对象表原顺序
                #确认插入对象 = 对象表[index]
#<确认插入对象>不应该取决于对象表原顺序
#因为位置表不一定按从小到大顺序排列
#如此我先插入到的位置不一定是位置表原顺序的[0]
#所以我先插入的对象不一定是对象表原顺序的[0]
#而应该按位置表与对象表的对应关系插入
#这对应关系是顺序对应的 之后位置表被打乱
#所以按排序后的位置表顺序对应的对象表顺序插入

#检测遍历得到的当前针对的<position>是否是重复位置
#如果不是重复位置
#则只需要用<对应关系dict版>
#如果是重复位置
#则需要动用<对应关系tuple版>来找到
#在dict版中被覆盖的对象
                if list.count(位置表,position)==1:
                    确认插入对象=对应关系dict版[position]
                else:
#寻找被覆盖的对象的方法是
#先得到该重复位置在<对应关系tuple版>中的切片
#即先得到<可能组>
#再取[0]得到<确认组> 取[1]得到<确认插入对象>
#再pop掉[0] 直到为空
#<可能组>不为空就不要重新赋值
#否则导致一直原地踏步
#<可能组>为空才可以重新赋值
#<可能组>本身为空
                    if not 可能组:
                        可能组=\
[tp for tp in 对应关系tuple版 if tp[0]==position]
                    确认组=可能组[0]
                    确认插入对象=确认组[1]
                    可能组.pop(0)
            
            副本.insert(确认插入到位置,确认插入对象)

    return 副本


#created:2021.7.1 16:43
#test_210701_列表同时插入多个元素.py
#列表同时插入多个元素

#note:2021.7.3 1:47~
#第一轮测试完毕 没出问题
#长度试过2 3的
#端值试过一个或多个超出len(source)的
#一个或多个0
#先试了内值的远离值 紧贴值
#再试了端值的远离值 紧贴值
#没有出任何问题
#updated:2021.7.3 1:52~
#再做些关卡加强

#updated:2021.7.6 16:14~
#当要在不同位置插入相同元素时
#预期是只写一次就行了
#目前不符预期 这问题要解决
#字典不允许重复键 这问题要解决

#updated:2021.7.6 16:23~
#先把以插入元素作为键 改为以插入位置作为键
#由此解决字典不允许重复键的问题
#updated:2021.7.6 23:41~
#修复由使用dict(zip())导致的受限于对称
#dict(zip())只能应对对称的情况
#在不对称时不要使用dict(zip())
#以list的索引号代替dict(zip())
#list的索引号既可可以应对对称的情况
#也可以应对不对称的情况
#由此不受限于对称

#updated:2021.7.7 1:27~
#先是通过不受限于对称实现了同一个元素插入到多个不同位置
#之后修正了我之前对elements参数的认知
#我一直以为elements的类型是受限的
#但其实我应该把它理解为object
#它不像positions位置那样
#必须是整数或整数序列不能是str的参数那样受限
#简而言之 我只应该去限制positions参数类型
#而不该限制elements参数类型
#所以两者长度不需要相同

#updated:2021.7.7 2:11~
#我明白了 如果不加模式 元素参数是分不清的
#还是应该视为object而不是element
#我也由此明白为什么Python自带的insert函数
#是把要插入的视为object而不是element
#object类型应该是不受限的
#而我的insertm想要实现同时插入多个元素
#而这元素又必须是用容器装 如此受限为容器类型
#就使得同一参数类型既不受限又受限 就出问题了

#updated:2021.7.7 2:17
#我不分模式了 要求元素参数必须为容器类型
#且是一个装object的容器
#该容器要么长度为1 视为对多个位置插入相同元素
#（即 长度为1 出现多次）
#要么长度不为1 视为对一一对应的位置插入一一对应的元素
#此时其长度必须等于位置参数值容器的长度
#即其长度受限为：长度==1 或 len(元素参数)==len(位置参数)
#而对于位置参数 要求必须为容器类型
#且只装int不能装其他
#当该容器长度为1 就是出现1次 绝不出现多次
#即位置参数不可以是int类型 而必须为装int的容器类型
#比如不可以 list().insertm(1,a)
#但可以  list().insertm([1],a)

#updated:2021.7.7 2:59~
#再优化 之前还是有些不必要的限制
#比如elements参数类型被限制为容器类型
#而我有需要它不受限的时候
#所以其实不必限制
#既然我有需要它为object类型的时候
#并且这时它为单个object
#就像我希望 list().insertm(1,a)
#不必转换为 list().insertm(1,[a])
#那么 if elements参数不是容器类型
#则说明其值为单个object
#则将这个object装进容器
#从而elements参数被转为容器类型
#位置参数同理 总之就是这样一种思维：
#先装进容器（已在容器内的不用装 不在容器内的要装进容器）
#再判断容器内容如何
#如此 位置参数值被装进容器后 该容器内容必须全部为int
#元素参数值被装进容器后
#该容器内容的数目必须与位置参数值容器的内容数目一致
#（此时insertm是将对应内容插入对应位置）
#（因为对应 所以数目要一致）
#除非该容器内容的数目为1
#（此时insertm是将相同内容插入不同位置）

#updated:2021.7.7 3:35~
#实现了传进来的不受限于容器类型
#然后修复了关卡次序问题

#updated:2021.7.11 1:03~1:14
#支持向同一位置先后插入不同对象
#修改变量名elements为objects
#positions参数称为位置表参数
#（而不再称为位置参数）
#objects参数称为对象表参数
#（而不再称为元素参数）
#updated:2021.7.11 1:27~
#检查了一遍 没出问题
#updated:2021.7.11 1:56~
#再次提示：如果你传一个列表进来
#并且你希望插入的对象是这个列表
#而不是列表里的元素
#那么你可以把这个列表放空列表里再插入
#否则如果直接插入 将不符你预期

#updated:2021.7.11 2:34~
#修复位置表里的元素不按从小到大顺序排列时会出现的问题
#办法是先对位置表里的元素进行排序
#由此支持了位置表里的元素不按从小到大顺序排列

#updated:2021.7.11 8:49~
#小修整：既然有<确认插入对象>
#那就该有<确认插入到位置>

#updated:2021.7.11 8:56~
#还是存在问题
#当位置表里的元素不按从小到大顺序排列时
#如果把位置表里的元素按从小到大顺序排列了
#那么对象表里的元素与位置表一一对应的顺序就不符预期了

#updated:2021.7.11 9:24~
#不应该按位置表原顺序插入
#而应该按位置表与对象表的对应关系插入
#所以按排序后的位置表顺序插入

#updated:2021.7.11 11:07~
#先使用dict(zip())得到不允许重复位置的对应关系
#干脆让它覆盖掉重复位置所对应的对象
#因为是根据位置表跟对应关系来插入
#所以我把位置表去重

#updated:2021.7.14 22:14~
#刚刚在终端试着把dict(zip())换成tuple(zip())
#发现可行 且不像dict那样存在不允许键重复的问题
#如此 我的list.insertm
#当位置不按从小到大顺序排列
#且存在重复元素时会出现的问题终于得以解决
#原来是这么简单
#把不允许键重复的dict改为tuple就行了
#也就是不要dict(zip())不要把zip转dict
#而是要tuple(zip())把zip转tuple
#这样就能重复了

#updated:2021.7.15 0:25~1:16
#解决了我的list.insertm这最后一个问题
#首先 所保存的位置表与对象表的对应关系
#dict版跟tuple版都要
#简单情况用dict版足够了 复杂情况再动用tuple版
#dict版就是不允许重复键版
#用于不存在重复位置的情况 即简单情况
#tuple版就是允许重复键版
#用于存在重复位置的情况 即复杂情况

#updated:2021.7.15 1:25~
#一定要区分position和<确认插入到位置>
#前者是最开始遍历得来的
#前者是从一开始就可以确定下来的

#updated:2021.7.15 1:28~
#一些变量改用中文命名

#note:2021.7.15 1:35~
#检查了一遍 没问题
#至此解决了我的list.insertm最后一个问题
#“当位置不按从小到大顺序排列且存在重复位置时”

#updated:2021.7.15 21:12~
#修复问题
#是用位置表[3,3,5,5]测出来的
#一定要注意<确认插入到位置>与position是不同的
#position才是真正的根据
#<确认插入到位置>是
#对于真正的根据——position的变动

#比如<位置表>按从小到大顺序排列后
#<确认插入到位置>就是position+index
#这就是<确认插入到位置>对于position的变动情况

#position才是<位置表>原内容
#position才是真正的根据
#一定要明白<确认插入到位置>是到最后insert才用的
#在insert之前要用到的作为根据的是position

#note:2021.7.15 21:25~
#问题已解决

#note:2021.7.15 21:45~
#至此 我的list.insertm终于完全没问题了

#note:2021.7.15 22:01~
#我的list.insertm暂不支持位置表多元素时含有负数


#updated:2022.7.14 16:20~
#修复传入位置表为tuple时的问题
