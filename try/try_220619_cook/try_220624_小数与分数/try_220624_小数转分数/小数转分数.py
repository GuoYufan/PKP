from SearchPath import *
from try_Using_最大公约数 import*
from try_Using_分数四则运算 import*

import math
from functools import reduce

class 小数转分数世界():
    def __init__(self):
        self.你的小数_字符串形式=""
        self.循环体长度=0
        
        
    def 判断是否是小数(self):
        try:self.你的小数_数值形式=float(self.你的小数_字符串形式)
        except ValueError:return False
        
        self.整部_数值形式=int(self.你的小数_数值形式)
        self.小数部分位数=len(self.你的小数_字符串形式)-len(str(self.整部_数值形式))-1
        if self.小数部分位数<1 or self.你的小数_数值形式==self.整部_数值形式:return False
        
        return True
        
    def 有限小数转分数(self):
        分数分部之分母=10**self.小数部分位数
#a=3.36
#b=str(a).split["."]
#b[1]
        self.小数部分_数值形式=int(self.你的小数_数值形式*分数分部之分母)-self.整部_数值形式*分数分部之分母        
        分数分部之分子=self.小数部分_数值形式
        约分后的分子,最终分母=map(int,获取最简分数((分数分部之分子,分数分部之分母)).split("/"))
        
        #根据分数整部分子变化
        最终分子=self.整部_数值形式*最终分母+约分后的分子        
        最终分数=f"{最终分子}/{最终分母}"
        
        return 最终分数
    
    
    def get_changed_part(self):
        循环部分变化为="%s/%s"%(self.循环部分, self.缩小倍数)
        self.result_空部不填_倍数缩小法=[self.整部,循环部分变化为,self.空部放回]
        循环部分变化为=连分数转换(循环部分变化为)
        self.result_空部不填_倍数缩小法_化简=[self.整部] + list(map(获取最简分数, (循环部分变化为,self.空部放回)))
        
        self.result_空部不填_倍数缩小法_计算后=reduce(分数四则运算, (self.result_空部不填_倍数缩小法_化简))
        
        循环部分变化为="%s-%s"%(self.循环部分, self.差值_结果)
        self.result_空部不填_数值减小法=[self.整部,循环部分变化为,self.空部放回]
        循环部分变化为="%s-%s"%(获取最简分数(self.循环部分), 获取最简分数(self.差值_结果))
        self.result_空部不填_数值减小法_化简=[self.整部, 循环部分变化为,获取最简分数(self.空部放回)]
        temp=self.result_空部不填_数值减小法_化简[:]
        for i in range(-1,-3,-1):
            temp.insert(1,temp[-2].split("-")[i])
        temp.pop(-2)
        temp[2]="-"+temp[2]
        self.result_空部不填_数值减小法_计算后=reduce(分数四则运算, temp)
        
        
        循环部分变化为="%s"%(self.循环部分_结果_循环体变化)
        空部放回变化为="%s"%(self.空部被填放回_结果_含整部)
        self.result_空部被填_循环体变化法=[循环部分变化为,空部放回变化为]
        self.result_空部被填_循环体变化法_化简=list(map(获取最简分数, (循环部分变化为,空部放回变化为)))
        self.result_空部被填_循环体变化法_计算后=reduce(分数四则运算, self.result_空部被填_循环体变化法_化简)
        
        
    def update_basic_info(self):
        if self.循环体长度<1:
            raise ValueError("❌循环体长度不能小于1")
        # 你的小数="6.2435"
        # 循环体长度=3
        
        # --- 《空 部 不 填 , 倍 数 缩 小》 专 用（空部不变，循环体不变，循环部分变化是相对于循环体的标准循环作倍数缩小的变化） ---
        # 整部="6"  小数部分="7435"
        self.整部,self.小数部分=self.你的小数_字符串形式.split(".")
        # 循环体="435"
        self.循环体=self.你的小数_字符串形式[-self.循环体长度:]
        # 循环体分母="9"*3="999"
        self.循环体分母="9"*self.循环体长度
        # 循环部分="435/999"
        self.循环部分="%s/%s"%(self.循环体, 	self.循环体分母)
        
        # 小数部分位数=6-1-1=4
        
        self.小数部分位数=len(self.你的小数_字符串形式)-len(self.整部)-1
        if self.循环体长度 > self.小数部分位数:
            raise Exception("❌无限循环小数转分数发生错误：循环体太长")
            
        
        # 空位=4-3=1
        self.空位=self.小数部分位数-self.循环体长度
        
        # 如果没有空位，说明只需要整部+循环部分即可，不需要空部。
        if self.空位==0: return
        
        
        # 空部="7435"[:-3]="7"
        self.空部=self.小数部分[:-self.循环体长度]
        
        # 缩小倍数=10**1=10
        self.缩小倍数=10**self.空位
        
        self.空部放回=f"{self.空部}/{self.缩小倍数}"
        # 0.7435435...->0.0435435...
        # 整部+循环部分缩小倍数+空部不变（其实就是0.654...->0.6是已知空位故而截取）


        # --- 《空 部 不 填, 倍 数 缩 小》 数 值 形 式 专 用 --+
        '''
        把空部提整（不需要与整部分开）（必须使用数值形式）：
        6.7435...*10//1=67
        
        再把空部放回（字符串形式）：
        67/10
        
        结果为：
        空部不变（含整部）+循环部分倍数缩小=67/10+435/999/10=(67+435/999)/10
        '''
        
        self.你的小数_数值形式=float(self.你的小数_字符串形式)        
        self.空部_含整部=self.你的小数_数值形式*self.缩小倍数//1
        self.空部放回_含整部=f"{self.空部_含整部}/{self.缩小倍数}"


        # --- 《空 部 不 填, 数 值 减 小 》 专 用（空部不变，循环体不变，循环部分是相对于循环体的标准循环作数值减小的变化） ---
        '''
        	6.7435...(3)
        	435/999 -> 435/999/10
        	435/999-435/999/10
        	=435/999-435/9990
        	=（4350-435）/9990
        	
        	435/999/10=435/999-（4350-435）/9990
        	
        空部不变（含整部）+循环部分数值减小=67/10+435/999-(4350-435)/9990
        
        '''
        self.循环体_数值形式=int(self.循环体)
        self.循环体分母_数值形式=int(self.循环体分母)
        self.循环部分="%g/%g"%(self.循环体_数值形式, self.循环体分母_数值形式)
        self.差值之分子_数值形式=(self.循环体_数值形式*self.缩小倍数-self.循环体_数值形式)
        self.差值之分母_数值形式=(self.循环体分母_数值形式*self.缩小倍数)
        self.差值_结果=f"{self.差值之分子_数值形式:g}/{self.差值之分母_数值形式:g}"
        
        # --- 《空 部 被 填》 专 用（空部变化，循环体变化，循环部分是相对于循环体的标准循环不变化） ---
        '''
        6.7435...(3)
        ->要用435填7435
        ->435不可能填得了，因为循环体是435，不是443
        ->第一位必须能接43，所以只有5，只有把435变成543去填
        ->把5435(1+3k)尽可能填满后，填不满之余是1。
        ->小数部分位数永远是1+3k，所以用3个去填，填到尽头余1。
        ->比如6.5435435435435...(3)
        ->找到第一个435后，知道是在-6。
        ->而小数后一位作在-3*4-1=-13
        ->所以两者之差-13-(-6)=-13+6=-7
        ->而要用3个填7个空，会余：7%3=1。
        ->会余1。
        ->所以把尾1移首。
        ->"435"[-1:]="5"
        ->"435"[:-1]="43"
        ->连接为"5"+"43"="543"
        ->所以不再使用435/999作为循环部分，而是使用543/999
        ->然后空部由于不像之前是空出0，是0.435...->0.0435...
        ->于是用6.7去加
        ->而是被填了5，7被填5，那么还剩2
        ->可是我怎么知道是填了呢？
        ->空位是1，5是"543"当中的一个。"543"[:空位]="543"[:1]="5"
        ->如果空位是2，就是填了"54"。所以"543"[:2]="54"
        ->如果空位是3，就是刚好填了一个循环体"543"。
        ->所以是"543"[:空位]喽？
        ->可是如果空位是4，"543"不够4个，不够填怎么办？
        ->因为循环体是"543"，所以我们可以猜到应该填"5435"。
        ->所以我们可以先把循环体拉长到"543543"
        ->我们知道原空部是原小数乘以缩小倍数就可以截取到。但是我如何得到"5435"呢？这并不能通过截取得到。
        ->math.ceil(a/b)是最好的拉长方法。它会把a/b得到的小数向上取整，而不是int()向下取整。
        ->这样当等于3是一个，等于6是两个。超过之后，只要超过就是多一个。
        ->超过说明需要补充，所以4是超过3，需要补充，所以math.ceil(4/3)得到两个。如果int(4/3)仍然是一个，没补充。
        ->所以同样是(67-5)/10
        ->空部变化_结果_含整部=(把空部提整（含整部）-填空)/缩小倍数=(67-5)/10
        ->空部变化_结果_含整部+循环部分_循环体变化=(67-5)/10+543/999
        ->再举个例子，空位很多的那种：
        ->6.7892435435...(3)
        ->空位=4
        ->这时435填不了7892
        ->于是10%3=1
        ->"435"->"543"
        ->6.543543
          6.789243
          对上了
        ->循环部分已经解决了，这时要找空部被填的情况
        ->空位//循环体长度+1=4//3+1=1+1=2
        ->("543"*2)[:4]="543543"[:4]="5435"
        
        
        填空之后_含整部+循环部分_循环体变化=(67-5)/10+543/999
        '''
        
        self.填不满之余位=self.小数部分位数%self.循环体长度
        self.新循环体=self.以头移尾(self.循环体, self.填不满之余位, True)
        self.循环部分_结果_循环体变化=f"{self.新循环体}/{self.循环体分母}"
        self.用来填空的=(self.新循环体*(math.ceil(self.空位/self.循环体长度)))[:self.空位]
        self.填空之后_含整部="%d"%(self.空部_含整部-int(self.用来填空的))
        self.空部被填放回_结果_含整部=f"{self.填空之后_含整部}/{self.缩小倍数}"
        
        
    def 以头移尾(self,原,移几位,反向=False):
        原=str(原)
        切出=原[:移几位] if not 反向 else 原[-移几位:]
        不动=原[移几位:] if not 反向 else 原[:-移几位]
        新=不动+切出 if not 反向 else 切出+不动
        
        return 新
    
    
    def 无限循环小数转分数(self):
        self.update_basic_info()
        self.get_changed_part()
        
        description=(
        	"⭐️方法一（空部不填之倍数缩小法）（准确率最高）\n◾️字符串形式之原式:",
        	"◾️化简:",
        	"◾️从而转为分数:",
        	
        	"⭐️方法二（空部不填之数值减小法）\n◾️字符串形式之原式:",
        	"◾️化简:",
        	"◾️从而转为分数:",
        	
        	"⭐️方法三（空部被填法之循环体变化法）（最简洁）\n◾️原式:",
        	"◾️化简:",
        	"◾️从而转为分数:",
        	)
        
        整合=zip(description,(
        	           "+".join(self.result_空部不填_倍数缩小法),
        	           "+".join(self.result_空部不填_倍数缩小法_化简),
        	           self.result_空部不填_倍数缩小法_计算后+"\n",
        		         
        		          "+".join(self.result_空部不填_数值减小法),
        		          "+".join(self.result_空部不填_数值减小法_化简),
        		          self.result_空部不填_数值减小法_计算后+"\n",
        		         
        		          "+".join(self.result_空部被填_循环体变化法),
        		          "+".join(self.result_空部被填_循环体变化法_化简),
        		          self.result_空部被填_循环体变化法_计算后+"\n",
        		          )
        		       )
        		
        return 整合
        
    def ask(self):
        while True:
            self.你的小数_字符串形式=input("\n◾️你的小数:")
            if not self.判断是否是小数():
                print("❌你这不是小数")
                continue
            break
        while True:
            try:self.循环体长度=int(input("◾️循环体长度:"))
            except:
                print("❌循环体长度必须是整数\n")
                continue
            if self.循环体长度<0:
                print("❌循环体长度不能小于0\n")
                continue
            break
            
    def 是否退出当前界面(self):
        return input("\n#Q/q to quit: ").lower()=="q"
    
                    
    def 给出解答界面(self):
        try:print("\n%s的分数形式是%s"%(self.你的小数_字符串形式, self.有限小数转分数()))
        except Exception as e:
            print(e)
            return
        
        if self.循环体长度:   
            try:无限循环小数转分数结果=self.无限循环小数转分数()
            except Exception as e:
                print(e)
                return "无限循环小数转分数时发生Error"
            print("\n%s%s...的分数形式是"%(self.你的小数_字符串形式, self.你的小数_字符串形式[-self.循环体长度:]*2))
            for key,value in 无限循环小数转分数结果:
                print(key,value,sep=str())
        
        

def main():    
    小数转分数=小数转分数世界()

    while True:
        小数转分数.ask()
        if 小数转分数.给出解答界面()=="无限循环小数转分数时发生Error":continue
        if 小数转分数.是否退出当前界面():break

if __name__=="__main__":
    main()    
    
    
# updated: 2025.1.22 0:12
# 《无限循环小数转分数》的问题终于修复到可用
# note: 2025.1.22 0:31
# 验证通过，没有问题

# updated: 2025.1.22 13:57
# 把化简和转为一个小数也重新写进来了，需求的实现终于基本已经完备，第一个可投入生产的正式版终于到来
# 《小数转分数》v1.0.0正式版
